\subsection{Prefetching}
\label{sec:prefetch}

% \cref{lst:TODO} is
Consider
a simplified version of \cref{lst:access-times} that, instead of using random accesses,
simply walks over the array sequentially.  It still follows the pointers to do this, but
the array is no longer shuffled.

% \emph{Cache prefetching} is a technique by which CPUs recognize predictable access
% patterns (for instance sequential access to an array)... TODO

\begin{figure}
   \centering
   \begin{tikzpicture}
      \datavisualization[%
         scientific axes=clean,
         x axis={%
            logarithmic,
            ticks={major={
               /pgf/number format/int detect,
               at={
                  2048 as 2, 8192 as 8, 32768 as \textbf{32}, 131072 as 128,
                  524288 as \textbf{512}, 2097152 as \pgfmathprintnumber{2048},
                  8388608 as \pgfmathprintnumber{8192},
                  33554432 as \pgfmathprintnumber{32768},
                  134217728 as \pgfmathprintnumber{131072},
            }}},
            grid={at={32768, 524288}},
            label={Array Size (KiB)},
            length=0.8\textwidth},
         y axis={include value=0, label={Cycles / Iteration}, length=6cm, grid=at ticks},
         visualize as scatter,
         scatter={style={mark=*, mark options={scale=.65}}}]
         data [read from file=seq-access-times/access-times.csv, separator=\space];
   \end{tikzpicture}
   \caption{Access Times for Sequential Reads}
   \label{fig:seq-access-times}
\end{figure}

% [1]: http://ithare.com/c-for-games-performance-allocations-and-data-locality/
% [2]: http://ithare.com/c-for-games-performance-allocations-and-data-locality/2/
% [3]: https://en.wikipedia.org/wiki/Cache_prefetching

% vim: tw=90 sts=-1 sw=3 et fdm=marker
